<!DOCTYPE html>
<html lang="en">
	<head>
		<title>qix</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <script src="https://cdn.jsdelivr.net/npm/polygon-clipping@0.15.3/dist/polygon-clipping.min.js"></script>
	</head>
	<body>
  <script type="importmap">
			{
				"imports": {
					"three": "./three/build/three.module.js",
					"three/addons/": "./three/examples/jsm/"
				}
			}
		</script>

<canvas id="can">No canvas</canvas>
<style>
body{padding:0;margin:0;overflow:hidden;background:black;}
#VRButton { left:calc(50% + 50px) !important; }
</style>

<script>
 //globals
 var qix=[];// 3d lines
 //var qiz=[];// coords
 var fps=30,step=10,lines=50,chc=lines/6,lw=3;
 var marker;
 var ww=window.innerWidth, hh=window.innerHeight;
</script>

<script type="module">
	import * as THREE from 'three';

			//import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { VRButton } from 'three/addons/webxr/VRButton.js';
   import { ARButton } from 'three/addons/webxr/ARButton.js';
   import { TransformControls } from 'three/addons/controls/TransformControls.js';
   //import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
   import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
   //import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, raycaster, renderer;
			let floor, baseReferenceSpace;
   let perimeterPoints = [], perimeterLine;
   let playerSegmentIndex = 0;
   let playerSegmentProgress = 0.0;
   let isDrawing = false;
   let playerLine;
   let playerLinePoints = [];
   let startSegmentIndex, startSegmentProgress;
   let currentDrawingDirection = 'none';

   let controller1, controller2;
			let controllerGrip1, controllerGrip2;
   let controls,group,linex;
   //let handedness;

			//let INTERSECTION;
			//const tempMatrix = new THREE.Matrix4();

   function getIntersectionPoint(p1, q1, p2, q2) {
    const r = new THREE.Vector3().subVectors(q1, p1);
    const s = new THREE.Vector3().subVectors(q2, p2);
    const rxs = r.x * s.y - r.y * s.x;
    const qp = new THREE.Vector3().subVectors(p2, p1);
    const qpxr = qp.x * r.y - qp.y * r.x;

    if (rxs === 0) return null; // Parallel or collinear

    const t = (qp.x * s.y - qp.y * s.x) / rxs;
    const u = qpxr / rxs;

    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
        return new THREE.Vector3().addVectors(p1, r.multiplyScalar(t));
    }

    return null;
   }

   function pointInPolygon(point, polygon) {
    let odd = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;

        if (((yi > point.y) !== (yj > point.y))
            && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
            odd = !odd;
        }
        j = i;
    }
    return odd;
   };

   function isPointOnSegment(p, a, b, tolerance = 0.001) {
    const ab = new THREE.Vector3().subVectors(b, a);
    const ap = new THREE.Vector3().subVectors(p, a);
    const cross = new THREE.Vector3().crossVectors(ab, ap).length();
    if (cross > tolerance) return false; // Not collinear

    const dot = ab.dot(ap);
    if (dot < 0) return false; // Outside segment, before a

    const lenSq = ab.lengthSq();
    if (dot > lenSq) return false; // Outside segment, after b

    return true;
   }

   function getClosestPointOnSegment(p, a, b) {
    const ab = new THREE.Vector3().subVectors(b, a);
    const ap = new THREE.Vector3().subVectors(p, a);
    const t = ap.dot(ab) / ab.lengthSq();
    if (t < 0.0) return a.clone();
    if (t > 1.0) return b.clone();
    return new THREE.Vector3().addVectors(a, ab.multiplyScalar(t));
   }

   function toGeoJSON(points) {
    return [[points.map(p => [p.x, p.y])]];
   }

   function fromGeoJSON(polygon) {
    return polygon[0][0].map(p => new THREE.Vector3(p[0], p[1], -5));
   }

   function getPolygonArea(points) {
    let area = 0;
    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
        area += points[i].x * points[j].y;
        area -= points[j].x * points[i].y;
    }
    return Math.abs(area / 2);
   }

   function updateGameArea(newPerimeterPoints) {
    perimeterPoints = newPerimeterPoints;

    // Update visual border
    scene.remove(perimeterLine);
    const perimeterMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
    const perimeterGeometry = new THREE.BufferGeometry().setFromPoints([...perimeterPoints, perimeterPoints[0]]);
    perimeterLine = new THREE.Line(perimeterGeometry, perimeterMaterial);
    scene.add(perimeterLine);

    // Update floor mesh
    const floorShape = new THREE.Shape(perimeterPoints.map(p => new THREE.Vector2(p.x, p.y)));
    const floorGeometry = new THREE.ShapeGeometry(floorShape);
    floor.geometry.dispose();
    floor.geometry = floorGeometry;
   }

 init();

 function init() {


	scene = new THREE.Scene();
		scene.background = new THREE.Color( 0x505050 );

  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, .1, 1000 );
  camera.position.set( 1.6,2 ,-4 );scene.add( camera );

  //const light = new THREE.AmbientLight( 0xffffff, 3 );
  //const light = new THREE.AmbientLight( 0xffffff,2 ); // soft white light
  //scene.add( light );

		const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 0, 6, 0 );
				light.castShadow = true;
				light.shadow.camera.top = 3;
				light.shadow.camera.bottom = - 3;
				light.shadow.camera.right = 3;
				light.shadow.camera.left = - 3;
				light.shadow.mapSize.set( 4096, 4096 );
				scene.add( light );

			//const light = new THREE.HemisphereLight( 0xfff0f0, 0x60606, 3 );
			//light.position.set( 1, 1, 1 );
			//scene.add( light );

		marker = new THREE.Mesh(
			new THREE.CircleGeometry( 0.05, 8 ),//.rotateX( -Math.PI/2 ),
			new THREE.MeshBasicMaterial( { color: 0xbcbcbc } )
		);
  scene.add( marker ); //player
  marker.rotateZ( -Math.PI/2 );

  // Game area
  const l = -3.05, r = 3.05, t = 4.05, b = -0.05, z = -5;
  perimeterPoints = [
      new THREE.Vector3(l, t, z),
      new THREE.Vector3(r, t, z),
      new THREE.Vector3(r, b, z),
      new THREE.Vector3(l, b, z)
  ];

  // Visual border
  const perimeterMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
  const perimeterGeometry = new THREE.BufferGeometry().setFromPoints([...perimeterPoints, perimeterPoints[0]]);
  perimeterLine = new THREE.Line(perimeterGeometry, perimeterMaterial);
  scene.add(perimeterLine);

  // Floor mesh
  const floorShape = new THREE.Shape(perimeterPoints.map(p => new THREE.Vector2(p.x, p.y)));
  const floorGeometry = new THREE.ShapeGeometry(floorShape);
  const floorMaterial = new THREE.MeshBasicMaterial({ color: 0xbcbcbc, transparent: true, opacity: 0.25 });
  floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.position.z = z;
  scene.add(floor);

  marker.position.copy(perimeterPoints[0]);

//SQ
/*const geo = new THREE.BufferGeometry();
  const vertices = [
    -1, 0, z,
    1, 0, z,
    1, 1, z,
    -1, 1, z
  ];
  const indices = [
    0, 1, 2, // first triangle
    2, 3, 0 // second triangle
  ];
  geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geo.setIndex(indices);
  const mat = new THREE.MeshBasicMaterial();
  const sq = new THREE.Mesh(geo, mat);
  scene.add(sq);
*/

  // l-r = 6*100=600
  // t-b = 4*100=400
  // total scaled is 600x400
  //write translation to convert 600x400 to (-3 to 3) and (0 to 4)
  // 4 to 400 is y*100
  // 400 to 4 is y/100
  // 3 to 600 is (x*100)+300
  // 600 to 3 is (x-300)/100


  var x1=1,x2=1,y1=2,y2=0;

  //console.log(new THREE.Vector3( x1, y1, z ));
  //console.log(new THREE.Vector3( x2, y2, z ));

  for (let i=1;i<lines;i++){
   var lnclr = new THREE.LineBasicMaterial({ color: 0x00ff00 });
   var qixp = []; //qix points
   qixp.push( new THREE.Vector3( x1, y1, z ) );
   qixp.push( new THREE.Vector3( x2, y2, z ) );
   var qixg = new THREE.BufferGeometry().setFromPoints( qixp ); //qix geometry
   qix[i] = new THREE.Line( qixg, lnclr ); //3d lines
   scene.add( qix[i] );
  }

	 raycaster = new THREE.Raycaster();

	 renderer = new THREE.WebGLRenderer( { antialias: true } );
	 renderer.setPixelRatio( window.devicePixelRatio );
	 renderer.setSize( window.innerWidth, window.innerHeight );
	 renderer.setAnimationLoop( animate );

	 renderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );
	renderer.xr.enabled = true;

  //renderer.toneMapping = THREE.ACESFilmicToneMapping;
		//renderer.toneMappingExposure = 1;
  renderer.autoClear = false;

  //renderer.xr.setReferenceSpaceType( 'local' );
	document.body.appendChild( renderer.domElement );
	document.body.appendChild( VRButton.createButton( renderer ) );
  document.body.appendChild( ARButton.createButton( renderer ) );
  window.addEventListener( 'resize', onWindowResize );

			// controllers
				controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'select', onSelect );
				controller1.addEventListener( 'selectstart', onControllerEvent );
				controller1.addEventListener( 'selectend', onControllerEvent );
				controller1.addEventListener( 'move', onControllerEvent );
				controller1.userData.active = false;
				scene.add( controller1 );
				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'select', onSelect );
				controller2.addEventListener( 'selectstart', onControllerEvent );
				controller2.addEventListener( 'selectend', onControllerEvent );
				controller2.addEventListener( 'move', onControllerEvent );
				controller2.userData.active = true;
				scene.add( controller2 );
			const controllerModelFactory = new XRControllerModelFactory();
				controllerGrip1 = renderer.xr.getControllerGrip( 0 );
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				scene.add( controllerGrip1 );
				controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );

   let gm = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				linex = new THREE.Line( gm );
				linex.name = 'linex';
				linex.scale.z = 5;

				raycaster = new THREE.Raycaster();

    controls = new TransformControls( camera, renderer.domElement );
				//controls.attach( group.children[ 0 ] );
				scene.add( controls.getHelper() );
 }
			function onSelect( event ) {

				const controller = event.target;

				controller1.userData.active = false;
				controller2.userData.active = false;

				if ( controller === controller1 ) {

					controller1.userData.active = true;
					//controller1.add( linex );

				}

				if ( controller === controller2 ) {

					controller2.userData.active = true;
					//controller2.add( linex );

				}

				raycaster.setFromXRController( controller );

				//const intersects = raycaster.intersectObjects( group.children );

				//if ( intersects.length > 0 ) {

					//controls.attach( intersects[ 0 ].object );

			//	}

			}

			function onControllerEvent( event ) {

				const controller = event.target;

				if ( controller.userData.active === false ) return;

				controls.getRaycaster().setFromXRController( controller );
     //console.log(controls);
    //console.log(event.type);

				switch ( event.type ) {

					case 'selectstart':
						if (!isDrawing) {
       isDrawing = true;
       currentDrawingDirection = 'none';
       startSegmentIndex = playerSegmentIndex;
       startSegmentProgress = playerSegmentProgress;
       playerLinePoints = [marker.position.clone()];
       const material = new THREE.LineBasicMaterial({ color: 0xff00ff });
       const geometry = new THREE.BufferGeometry().setFromPoints(playerLinePoints);
       playerLine = new THREE.Line(geometry, material);
       scene.add(playerLine);
      }
						break;

					case 'selectend':
						if (isDrawing) {
       isDrawing = false;
       currentDrawingDirection = 'none';
       scene.remove(playerLine);
       playerLine = null;
       playerLinePoints = [];

       // Snap player back to where they started
       playerSegmentIndex = startSegmentIndex;
       playerSegmentProgress = startSegmentProgress;
       const startPoint = perimeterPoints[playerSegmentIndex];
       const endPoint = perimeterPoints[(playerSegmentIndex + 1) % perimeterPoints.length];
       marker.position.lerpVectors(startPoint, endPoint, playerSegmentProgress);
      }
						break;

					case 'move':
						//controls.pointerHover( null );
						//controls.pointerMove( null );
						break;

				}

			}
   function handlePerimeterMovement(data) {
    const d = (Math.abs(data[1].axes[2]) > Math.abs(data[2].axes[2])) ? data[1].axes[2] : data[2].axes[2];
    if (Math.abs(d) > 0.1) {
        const speed = d;
        const progressChange = speed * 0.01;

        playerSegmentProgress += progressChange;

        if (playerSegmentProgress > 1.0) {
            playerSegmentProgress -= 1.0;
            playerSegmentIndex = (playerSegmentIndex + 1) % perimeterPoints.length;
        } else if (playerSegmentProgress < 0.0) {
            playerSegmentProgress += 1.0;
            playerSegmentIndex = (playerSegmentIndex - 1 + perimeterPoints.length) % perimeterPoints.length;
        }

        const startPoint = perimeterPoints[playerSegmentIndex];
        const endPoint = perimeterPoints[(playerSegmentIndex + 1) % perimeterPoints.length];
        marker.position.lerpVectors(startPoint, endPoint, playerSegmentProgress);
    }
   }

   function handleDrawingMovement(data) {
    const c = (Math.abs(data[1].axes[3]) > Math.abs(data[2].axes[3])) ? data[1].axes[3] : data[2].axes[3]; // up-dn
    const d = (Math.abs(data[1].axes[2]) > Math.abs(data[2].axes[2])) ? data[1].axes[2] : data[2].axes[2]; // lf-rt
    const speed = 0.05;

    if (currentDrawingDirection === 'none') {
        if (Math.abs(d) > 0.5) {
            currentDrawingDirection = 'horizontal';
        } else if (Math.abs(c) > 0.5) {
            currentDrawingDirection = 'vertical';
        }
    }

    const lastPoint = playerLinePoints[playerLinePoints.length - 1];

    if (currentDrawingDirection === 'horizontal') {
        if (Math.abs(c) > 0.5) { // Change direction
            playerLinePoints.push(lastPoint.clone());
            currentDrawingDirection = 'vertical';
        } else {
            marker.position.x += Math.sign(d) * speed;
        }
    }

    if (currentDrawingDirection === 'vertical') {
        if (Math.abs(d) > 0.5) { // Change direction
            playerLinePoints.push(lastPoint.clone());
            currentDrawingDirection = 'horizontal';
        } else {
            marker.position.y -= Math.sign(c) * speed;
        }
    }

    playerLine.geometry.setFromPoints([...playerLinePoints, marker.position]);


    // Intersection Check
    if (playerLinePoints.length > 0) {
        const p1 = lastPoint;
        const q1 = marker.position;

        for (let i = 0; i < perimeterPoints.length; i++) {
            const p2 = perimeterPoints[i];
            const q2 = perimeterPoints[(i + 1) % perimeterPoints.length];

            if (i === startSegmentIndex) continue;

            const intersectionPoint = getIntersectionPoint(p1, q1, p2, q2);
            if (intersectionPoint) {
                playerLinePoints.push(intersectionPoint);
                const endSegmentIndex = i;

                // Build the two potential new perimeters by walking the old one
                const poly1 = [...playerLinePoints];
                let j = endSegmentIndex;
                while (j !== startSegmentIndex) {
                    poly1.push(perimeterPoints[j]);
                    j = (j + 1) % perimeterPoints.length;
                }
                poly1.push(perimeterPoints[startSegmentIndex]);


                const poly2 = [...playerLinePoints];
                j = startSegmentIndex;
                while (j !== endSegmentIndex) {
                    poly2.push(perimeterPoints[j]);
                    j = (j + 1) % perimeterPoints.length;
                }
                poly2.push(perimeterPoints[endSegmentIndex]);

                const qixGeometry = qix[10].geometry.attributes.position;
                const qixPoint = new THREE.Vector3(qixGeometry.getX(0), qixGeometry.getY(0), -5);

                let newPerimeter;
                if (pointInPolygon(qixPoint, poly1)) {
                    newPerimeter = poly1;
                } else {
                    newPerimeter = poly2;
                }

                updateGameArea(newPerimeter);

                isDrawing = false;
                currentDrawingDirection = 'none';
                scene.remove(playerLine);
                playerLine = null;
                playerLinePoints = [];

                let closestPoint = null;
                let closestDistSq = Infinity;
                let newSegmentIndex = 0;
                let newSegmentProgress = 0;
                for (let k = 0; k < perimeterPoints.length; k++) {
                    const p1_snap = perimeterPoints[k];
                    const p2_snap = perimeterPoints[(k + 1) % perimeterPoints.length];
                    const pointOnSegment = getClosestPointOnSegment(marker.position, p1_snap, p2_snap);
                    const distSq = marker.position.distanceToSquared(pointOnSegment);
                    if (distSq < closestDistSq) {
                        closestDistSq = distSq;
                        closestPoint = pointOnSegment;
                        newSegmentIndex = k;
                        const segmentLength = p1_snap.distanceTo(p2_snap);
                        newSegmentProgress = (segmentLength > 0) ? closestPoint.distanceTo(p1_snap) / segmentLength : 0;
                    }
                }
                marker.position.copy(closestPoint);
                playerSegmentIndex = newSegmentIndex;
                playerSegmentProgress = newSegmentProgress;

                break;
            }
        }
    }
   }

 function animate() {
  const session = renderer.xr.getSession();
  if (session) {
   let a,b,c,d,hand,data=[];
   for (const source of session.inputSources) {
    if (source && source.handedness) {
     if (typeof source.handedness!=undefined){
      hand= source.handedness=='left'?1:2;
     } else { hand=0; }
    }

    if (!source.gamepad) continue;
      data[hand] = {
      hand: hand,
      buttons: source.gamepad.buttons.map((b) => b.value),
      axes: source.gamepad.axes.slice(0)
     }
    }

      if (data[1] && data[2]){
        if (!isDrawing) {
            handlePerimeterMovement(data);
        } else {
            handleDrawingMovement(data);
        }
      }
     }
  // Qix animation logic
  let tmp, vt;
  iii++;
  if (iii > chc) {
      iii = 0;
      rbi++;
      rbi = rbi > rb.length - 1 ? 0 : rbi;
      tmp = x([rb[rbi][0], rb[rbi][1], rb[rbi][2]]);
  } else {
      tmp = [rgb[lines - 1][0], rgb[lines - 1][1], rgb[lines - 1][2]];
  }
  rgb.shift();
  rgb.push(tmp);

  for (let i = 0; i < lines; i++) {
      if (i < lines - 1) {
          for (let it = 0; it < 3; it++) {
              if (rgb[i][it] == 0) { rgb[i][it] = 0; }
              else if (rgb[i][it] < cvs[i + 1]) { rgb[i][it] = cvs[i] / 2; }
              else { rgb[i][it] = cvs[i]; }
          }
      }

      if (cd[i] == undefined && i > 0) {
          cd.push([cd[i - 1][0] + step, cd[i - 1][1] + step, cd[i - 1][2] + step, cd[i - 1][3] + step]);
      }
      if (cd[i] == undefined && i == 0) {
          cd.push([rand(9, ww - 9), rand(9, hh - 9), rand(9, ww - 9), rand(9, hh - 9)]);
          vt = [rand("t"), rand("t"), rand("t"), rand("t")];
      }
      if (i == 0) {
          if (cd[i][0] > 5 && cd[i][0] < ww - 5) { vt[0] = rand(0, 200) != 1 ? vt[0] : vt[0] * -1; }
          if (cd[i][1] > 5 && cd[i][1] < hh - 5) { vt[1] = rand(0, 200) != 1 ? vt[1] : vt[1] * -1; }
          if (cd[i][2] > 5 && cd[i][2] < ww - 5) { vt[2] = rand(0, 200) != 1 ? vt[2] : vt[2] * -1; }
          if (cd[i][3] > 5 && cd[i][3] < hh - 5) { vt[3] = rand(0, 200) != 1 ? vt[3] : vt[3] * -1; }
          if (cd[i][0] > ww) { vt[0] = -1; }
          if (cd[i][0] < 0) { vt[0] = 1; }
          if (cd[i][1] > hh) { vt[1] = -1; }
          if (cd[i][1] < 0) { vt[1] = 1; }
          if (cd[i][2] > ww) { vt[2] = -1; }
          if (cd[i][2] < 0) { vt[2] = 1; }
          if (cd[i][3] > hh) { vt[3] = -1; }
          if (cd[i][3] < 0) { vt[3] = 1; }
          cd.unshift([cd[i][0] + vt[0] * step, cd[i][1] + vt[1] * step, cd[i][2] + vt[2] * step, cd[i][3] * step]);
          cd.pop();
      }
      if (cd[lines - i] != undefined && qix[i]) {
          let r = rgb[i][0]; let g = rgb[i][1]; let b = rgb[i][2];
          qix[i].material.color.r = r / 255;
          qix[i].material.color.g = g / 255;
          qix[i].material.color.b = b / 255;

          qix[i].geometry.attributes.position.array[0] = trz(cd[lines - i][0], 1);
          qix[i].geometry.attributes.position.array[1] = trz(cd[lines - i][1], 3);
          qix[i].geometry.attributes.position.array[3] = trz(cd[lines - i][2], 1);
          qix[i].geometry.attributes.position.array[4] = trz(cd[lines - i][3], 3);
          qix[i].geometry.attributes.position.needsUpdate = true;
      }
  }

  renderer.render( scene, camera );
 }

 function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
 }

</script>
<script>

function trz(n,d=1){
 //write translation to convert 600x400 to (-3 to 3) and (0 to 4)
 var out;
 if (d==1) {
  out=(n-(ww/2))/(ww/6); // 600 to 3 is (x-300)/100
 }
 if (d==2) {
  //out=n*my; // 4 to 400 is y*100
 }
 if (d==3) {
  out= 4-(n/(hh/4)); // 400 to 4 is y/100
 }
 if (d==4) {
  //out=(n*100)+(mx/2); // 3 to 600 is (x*100)+300
 }
 return out;
}



//var fps=30,step=10,lines=100,chc=lines/6,lw=3;
var rb=["201","001","010","110","120","100"]; rbi=0;
var mx,my,iii,nm=0,iii=999;
var cd=[],rgb=[],cvs=[];
var can=document.getElementById("can");
var ctx=can.getContext("2d");
ctx.lineWidth=lw;
for (let i=0;i<lines;i++){
  nm+=Math.round(255/lines);
  cvs.push(nm);
  rgb.push([ 0,0,0 ]);
}
window.onresize = function(event) { init(); };
init();


function init(){
 can.width=window.innerWidth; can.height=window.innerHeight;
 mx=can.width; my=can.height;
}

function rand(lo,hi=1,st=0){
 if (lo=="t"){out=Math.round(Math.random()) ? -1:1;}else{out=(Math.round(Math.random()*(hi-lo)))+lo;}
 return st ? String(out):out;
}

function x(x){
  out=[0,0,0];
  for (let z=0;z<3;z++){
   if (x[z]=="0") { out[z]=0 }
   else if (x[z]=="1") { out[z]=cvs[lines-1] }
   else if (x[z]=="2") { out[z]=cvs[lines-1]/2 }
  }
  return out;
}

</script>
</body>
</html>