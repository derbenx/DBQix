<!DOCTYPE html>
<html lang="en">
	<head>
		<title>qix</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	</head>
	<body>
 <script type="importmap">
			{
				"imports": {
					"three": "./three/build/three.module.js",
					"three/addons/": "./three/examples/jsm/"
				}
			}
		</script>

<style>
body{padding:0;margin:0;overflow:hidden;background:black;}
#VRButton { left:calc(50% + 50px) !important; }
</style>

<script type="module">
	import * as THREE from 'three';

			//import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { VRButton } from 'three/addons/webxr/VRButton.js';
   import { ARButton } from 'three/addons/webxr/ARButton.js';
   import { TransformControls } from 'three/addons/controls/TransformControls.js';
   import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
   //import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, raycaster, renderer;
			let floor, baseReferenceSpace;

   let controller1, controller2;
			let controllerGrip1, controllerGrip2;
   let controls,group,linex, playArea, playAreaVerts, isDrawing = false, playerPath = [], playerLine = null;

   // Game variables
   var qix=[];
   var marker;
   var fps=30,step=10,lines=50,chc=lines/6,lw=3;
   var rb=["201","001","010","110","120","100"];
   var rbi=0;
   var mx,my,iii=999,nm=0;
   var cd=[],rgb=[],cvs=[];
   var vt=[];
   var ww, hh;


function isonedge(point, polygon) {
  for (var i = 0; i < polygon.length; i++) {
    let p1 = polygon[i];
    let p2 = polygon[(i + 1) % polygon.length]; // Next vertex, wraps around
    let tolerance = 0.1;
    let dist = point.distanceTo(p1) + point.distanceTo(p2);
    let edgeLength = p1.distanceTo(p2);
    if (Math.abs(dist - edgeLength) < tolerance) {
      return true;
    }
  }
  return false;
}

function findEdge(point, polygon) {
  for (var i = 0; i < polygon.length; i++) {
    let p1 = polygon[i];
    let p2 = polygon[(i + 1) % polygon.length];
    let tolerance = 0.1;
    let dist = point.distanceTo(p1) + point.distanceTo(p2);
    let edgeLength = p1.distanceTo(p2);
    if (Math.abs(dist - edgeLength) < tolerance) {
      return i; // Return the index of the starting vertex of the edge
    }
  }
  return -1;
}

function isInside(point, vs) {
    // ray-casting algorithm based on
    // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html

    var x = point[0], y = point[1];

    var inside = false;
    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        var xi = vs[i][0], yi = vs[i][1];
        var xj = vs[j][0], yj = vs[j][1];

        var intersect = ((yi > y) != (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }

    return inside;
}

function trz(n,d=1){
 //write translation to convert 600x400 to (-3 to 3) and (0 to 4)
 var out;
 if (d==1) {
  out=(n-(ww/2))/(ww/6); // 600 to 3 is (x-300)/100
 }
 if (d==3) {
  out= 4-(n/(hh/4)); // 400 to 4 is y/100
 }
 return out;
}

function rand(lo,hi=1,st=0){
 if (lo=="t"){out=Math.round(Math.random()) ? -1:1;}else{out=(Math.round(Math.random()*(hi-lo)))+lo;}
 return st ? String(out):out;
}

function x(x){
  let out=[0,0,0];
  for (let z=0;z<3;z++){
   if (x[z]=="0") { out[z]=0 }
   else if (x[z]=="1") { out[z]=cvs[lines-1] }
   else if (x[z]=="2") { out[z]=cvs[lines-1]/2 }
  }
  return out;
}

 init();

 function init() {

    ww = window.innerWidth;
    hh = window.innerHeight;
    mx = ww;
    my = hh;

	scene = new THREE.Scene();
		scene.background = new THREE.Color( 0x505050 );

  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, .1, 1000 );
  camera.position.set( 1.6,2 ,-4 );scene.add( camera );

		const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 0, 6, 0 );
				light.castShadow = true;
				light.shadow.camera.top = 3;
				light.shadow.camera.bottom = - 3;
				light.shadow.camera.right = 3;
				light.shadow.camera.left = - 3;
				light.shadow.mapSize.set( 4096, 4096 );
				scene.add( light );

		marker = new THREE.Mesh(
			new THREE.CircleGeometry( 0.05, 8 ),//.rotateX( -Math.PI/2 ),
			new THREE.MeshBasicMaterial( { color: 0xbcbcbc } )
		);
  scene.add( marker ); //player
  marker.rotateZ( -Math.PI/2 );
  marker.position.z=-5;
  marker.position.y=-.05;

  floor = new THREE.Mesh(
			new THREE.PlaneGeometry( 3, 4, 1, 1 ).rotateX( -Math.PI/2 ),
			new THREE.MeshBasicMaterial( { color: 0xbcbcbc, transparent: true, opacity: 0.25 } )
		);
		scene.add( floor );

  const material = new THREE.LineBasicMaterial({ color: 0x000000 });
  const l=-3.05,r=3.05,t=4.05,b=-0.05,z=-5;

  playAreaVerts = [
    new THREE.Vector3( l, b, z ),
    new THREE.Vector3( l, t, z ),
    new THREE.Vector3( r, t, z ),
    new THREE.Vector3( r, b, z )
  ];

  const playAreaGeometry = new THREE.BufferGeometry().setFromPoints( playAreaVerts );
  playArea = new THREE.LineLoop( playAreaGeometry, material );
  scene.add( playArea );

  window.playAreaCanvasVerts = playAreaVerts.map(v => {
    const x = (v.x * (window.innerWidth / 6)) + (window.innerWidth / 2);
    const y = (4 - v.y) * (window.innerHeight / 4);
    return [x, y];
  });

//SQ
const geo = new THREE.BufferGeometry();
  const vertices = [
    -1, 0, z,
    1, 0, z,
    1, 1, z,
    -1, 1, z
  ];
  const indices = [
    0, 1, 2, // first triangle
    2, 3, 0 // second triangle
  ];
  geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geo.setIndex(indices);
  const mat = new THREE.MeshBasicMaterial();
  const sq = new THREE.Mesh(geo, mat);
  scene.add(sq);

  for (let i=0;i<lines;i++){
    nm+=Math.round(255/lines);
    cvs.push(nm);
    rgb.push([ 0,0,0 ]);
  }

  var x1=1,x2=1,y1=2,y2=0;

  for (let i=1;i<lines;i++){
   var lnclr = new THREE.LineBasicMaterial({ color: 0x00ff00 });
   var qixp = []; //qix points
   qixp.push( new THREE.Vector3( x1, y1, z ) );
   qixp.push( new THREE.Vector3( x2, y2, z ) );
   var qixg = new THREE.BufferGeometry().setFromPoints( qixp ); //qix geometry
   qix[i] = new THREE.Line( qixg, lnclr ); //3d lines
   scene.add( qix[i] );
  }

	 raycaster = new THREE.Raycaster();

	 renderer = new THREE.WebGLRenderer( { antialias: true } );
	 renderer.setPixelRatio( window.devicePixelRatio );
	 renderer.setSize( window.innerWidth, window.innerHeight );
	 renderer.setAnimationLoop( animate );

	 renderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );
	renderer.xr.enabled = true;

  renderer.autoClear = false;

	document.body.appendChild( renderer.domElement );
	document.body.appendChild( VRButton.createButton( renderer ) );
  document.body.appendChild( ARButton.createButton( renderer ) );
  window.addEventListener( 'resize', onWindowResize );

			// controllers
				controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'select', onSelect );
				controller1.addEventListener( 'selectstart', onControllerEvent );
				controller1.addEventListener( 'selectend', onControllerEvent );
				controller1.addEventListener( 'move', onControllerEvent );
				controller1.userData.active = false;
				scene.add( controller1 );
				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'select', onSelect );
				controller2.addEventListener( 'selectstart', onControllerEvent );
				controller2.addEventListener( 'selectend', onControllerEvent );
				controller2.addEventListener( 'move', onControllerEvent );
				controller2.userData.active = true;
				scene.add( controller2 );
			const controllerModelFactory = new XRControllerModelFactory();
				controllerGrip1 = renderer.xr.getControllerGrip( 0 );
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				scene.add( controllerGrip1 );
				controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );

   let gm = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				linex = new THREE.Line( gm );
				linex.name = 'linex';
				linex.scale.z = 5;

				raycaster = new THREE.Raycaster();

    controls = new TransformControls( camera, renderer.domElement );
				//controls.attach( group.children[ 0 ] );
				scene.add( controls.getHelper() );
 }
			function onSelect( event ) {

				const controller = event.target;

				controller1.userData.active = false;
				controller2.userData.active = false;

				if ( controller === controller1 ) {

					controller1.userData.active = true;
					//controller1.add( linex );

				}

				if ( controller === controller2 ) {

					controller2.userData.active = true;
					//controller2.add( linex );

				}

				raycaster.setFromXRController( controller );
			}

			function onControllerEvent( event ) {

				const controller = event.target;

				if ( controller.userData.active === false ) return;

				controls.getRaycaster().setFromXRController( controller );

				switch ( event.type ) {

					case 'selectstart':
						break;

					case 'selectend':
						break;

					case 'move':
						break;

				}

			}
 function animate() {
  const session = renderer.xr.getSession();
  if (session) {
   let a,b,c,d,hand,data=[];
   for (const source of session.inputSources) {
    if (source && source.handedness) {
     if (typeof source.handedness!=undefined){
      hand= source.handedness=='left'?1:2;
     } else { hand=0; }
    }

    if (!source.gamepad) continue;
      data[hand] = {
      hand: hand,
      buttons: source.gamepad.buttons.map((b) => b.value),
      axes: source.gamepad.axes.slice(0)
     }
    }

      if (data[1]){
       a=Math.abs(data[1].axes[3]);
       b=Math.abs(data[2].axes[3]);
       c=a>b?data[1].axes[3]:data[2].axes[3];
       a=Math.abs(data[1].axes[2]);
       b=Math.abs(data[2].axes[2]);
       d=a>b?data[1].axes[2]:data[2].axes[2];
      }

      if (Math.abs(c)>0 || Math.abs(d)>0) {
       if (Math.abs(c)>Math.abs(d)) { //up-dn
        marker.position.y-= c/50;
       } else { //lf-rt
        marker.position.x+= d/50;
       }

      if (marker.position.x>3.05){ marker.position.x=3.05; }
      if (marker.position.y>4.05){ marker.position.y=4.05; }
      if (marker.position.x<-3.05){ marker.position.x=-3.05; }
      if (marker.position.y<-.05){ marker.position.y=-.05; }

      }

    // Drawing logic
    if (data[1]) { // Check if left controller exists
     if (data[1].buttons[0] > 0.5 && !isDrawing) {
      if (isonedge(marker.position, playAreaVerts)) {
       isDrawing = true;
       playerPath = [marker.position.clone()];
      }
     }

     if (data[1].buttons[0] < 0.5 && isDrawing) {
      isDrawing = false;
      if(playerLine){
       playerLine.geometry.dispose();
       playerLine.material.dispose();
       scene.remove(playerLine);
       playerLine = null;
      }
      playerPath = [];
     }
    }

    if (isDrawing) {
     playerPath.push(marker.position.clone());

     if (playerLine) {
      playerLine.geometry.dispose();
      scene.remove(playerLine);
     }
     const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff });
     const lineGeometry = new THREE.BufferGeometry().setFromPoints(playerPath);
     playerLine = new THREE.Line(lineGeometry, lineMaterial);
     scene.add(playerLine);

     if (playerPath.length > 2 && isonedge(marker.position, playAreaVerts)) {
      isDrawing = false;

      let startPoint = playerPath[0];
      let endPoint = playerPath[playerPath.length - 1];
      let startEdgeIndex = findEdge(startPoint, playAreaVerts);
      let endEdgeIndex = findEdge(endPoint, playAreaVerts);

      if (startEdgeIndex !== -1 && endEdgeIndex !== -1) {
          let polyA = [];
          polyA.push(startPoint);
          let i = (startEdgeIndex + 1) % playAreaVerts.length;
          while (i !== (endEdgeIndex + 1) % playAreaVerts.length) {
              polyA.push(playAreaVerts[i]);
              i = (i + 1) % playAreaVerts.length;
          }
          polyA.push(endPoint);
          polyA.push(...[...playerPath].reverse());

          let polyB = [];
          polyB.push(endPoint);
          i = (endEdgeIndex + 1) % playAreaVerts.length;
          while (i !== (startEdgeIndex + 1) % playAreaVerts.length) {
              polyB.push(playAreaVerts[i]);
              i = (i + 1) % playAreaVerts.length;
          }
          polyB.push(startPoint);
          polyB.push(...playerPath);

          let polyA_canvas = polyA.map(v => {
              const x = (v.x * (ww / 6)) + (ww / 2);
              const y = (4 - v.y) * (hh / 4);
              return [x, y];
          });
          let polyB_canvas = polyB.map(v => {
              const x = (v.x * (ww / 6)) + (ww / 2);
              const y = (4 - v.y) * (hh / 4);
              return [x, y];
          });

          let qix_p1 = [cd[0][0], cd[0][1]];
          let newPlayAreaVerts = null;

          if (isInside(qix_p1, polyA_canvas)) {
              newPlayAreaVerts = polyA;
          } else {
              newPlayAreaVerts = polyB;
          }

          playAreaVerts = newPlayAreaVerts;
          playArea.geometry.dispose();
          playArea.geometry = new THREE.BufferGeometry().setFromPoints(playAreaVerts);

          window.playAreaCanvasVerts = playAreaVerts.map(v => {
              const x = (v.x * (ww / 6)) + (ww / 2);
              const y = (4 - v.y) * (hh / 4);
              return [x, y];
          });
      }

      if(playerLine){
       playerLine.geometry.dispose();
       playerLine.material.dispose();
       scene.remove(playerLine);
       playerLine = null;
      }
      playerPath = [];
     }
    }

    // Qix logic
    iii++;
    let tmp;
    if (iii>chc){
     iii=0;
     rbi++;
     rbi= rbi>rb.length-1 ? 0 : rbi;

     tmp=[ rb[rbi][0],rb[rbi][1],rb[rbi][2]] ;
     tmp=x(tmp);
    } else {
     tmp=[rgb[lines-1][0],rgb[lines-1][1],rgb[lines-1][2]];
    }
    rgb.shift();
    rgb.push(tmp);

    for (let i=0;i<lines;i++){

    if (i<lines-1){
     for (let it=0;it<3;it++){
      if (rgb[i][it]==0) { rgb[i][it]=0 }
      else if (rgb[i][it]<cvs[i+1]) { rgb[i][it]=cvs[i]/2 }
      else { rgb[i][it]=cvs[i] }
     }
    }

     if (cd[i]==undefined && i>0){
      cd.push([cd[i-1][0]+step,cd[i-1][1]+step,cd[i-1][2]+step,cd[i-1][3]+step]);
     }
     if (cd[i]==undefined && i==0){
      cd.push([rand(9,mx-9),rand(9,my-9),rand(9,mx-9),rand(9,my-9)]);
      vt=[rand("t"),rand("t"),rand("t"),rand("t")];
     }
     if (i==0){
      if (window.playAreaCanvasVerts && window.playAreaCanvasVerts.length > 0) {
          let p1_next = [cd[i][0] + vt[0]*step, cd[i][1] + vt[1]*step];
          if (!isInside(p1_next, window.playAreaCanvasVerts)) {
              vt[0] *= -1;
              vt[1] *= -1;
          }

          let p2_next = [cd[i][2] + vt[2]*step, cd[i][3] + vt[3]*step];
          if (!isInside(p2_next, window.playAreaCanvasVerts)) {
              vt[2] *= -1;
              vt[3] *= -1;
          }
      }
      cd.unshift([cd[i][0]+vt[0]*step,cd[i][1]+vt[1]*step,cd[i][2]+vt[2]*step,cd[i][3]*vt[3]*step]);
      cd.pop();
     }
     if (cd[lines-i]!=undefined){
      let r=rgb[i][0]; let g=rgb[i][1]; let b=rgb[i][2];
      qix[i].material.color.r=r/255;
      qix[i].material.color.g=g/255;
      qix[i].material.color.b=b/255;

      qix[i].geometry.attributes.position.array[0]=trz(cd[lines-i][0],1);
      qix[i].geometry.attributes.position.array[1]=trz(cd[lines-i][1],3);
      qix[i].geometry.attributes.position.array[3]=trz(cd[lines-i][2],1);
      qix[i].geometry.attributes.position.array[4]=trz(cd[lines-i][3],3);
      qix[i].geometry.attributes.position.needsUpdate = true;
     }
    }

     }

  renderer.render( scene, camera );
 }

 function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
        mx = window.innerWidth;
        my = window.innerHeight;
 }

</script>
</body>
</html>
