<!DOCTYPE html>
<html lang="en">
	<head>
		<title>qix</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	</head>
	<body>
 <script type="importmap">
			{
				"imports": {
					"three": "../vr/three.js-r178/build/three.module.js",
					"three/addons/": "../vr/three.js-r178/examples/jsm/"
				}
			}
		</script>

<canvas id="can">No canvas</canvas>
<style>
body{padding:0;margin:0;overflow:hidden;background:black;}
#VRButton { left:calc(50% + 50px) !important; }
</style>

<script>
 //globals
 var qix=[];// 3d lines
 //var qiz=[];// coords 
 var fps=30,step=10,lines=50,chc=lines/6,lw=3;
 var marker;
 var ww=window.innerWidth, hh=window.innerHeight;
</script>

<script type="module">
 	import * as THREE from 'three';

			//import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { VRButton } from 'three/addons/webxr/VRButton.js';
   import { ARButton } from 'three/addons/webxr/ARButton.js';
   import { TransformControls } from 'three/addons/controls/TransformControls.js';
   import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
   //import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
   
			let camera, scene, raycaster, renderer;
			let floor, baseReferenceSpace;
   
   let controller1, controller2;
			let controllerGrip1, controllerGrip2;
   let controls,group,linex;
   //let handedness;

			//let INTERSECTION;
			//const tempMatrix = new THREE.Matrix4();

 init();
   
 function init() {
 

 	scene = new THREE.Scene();
		scene.background = new THREE.Color( 0x505050 );

  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, .1, 1000 );
  camera.position.set( 1.6,2 ,-4 );scene.add( camera );
  
  //const light = new THREE.AmbientLight( 0xffffff, 3 );
  //const light = new THREE.AmbientLight( 0xffffff,2 ); // soft white light
  //scene.add( light );
  
  		const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 0, 6, 0 );
				light.castShadow = true;
				light.shadow.camera.top = 3;
				light.shadow.camera.bottom = - 3;
				light.shadow.camera.right = 3;
				light.shadow.camera.left = - 3;
				light.shadow.mapSize.set( 4096, 4096 );
				scene.add( light );
  
			//const light = new THREE.HemisphereLight( 0xfff0f0, 0x60606, 3 );
			//light.position.set( 1, 1, 1 );
			//scene.add( light );

		marker = new THREE.Mesh(
			new THREE.CircleGeometry( 0.05, 8 ),//.rotateX( -Math.PI/2 ),
			new THREE.MeshBasicMaterial( { color: 0xbcbcbc } )
		);
  scene.add( marker ); //player
  marker.rotateZ( -Math.PI/2 );
  marker.position.z=-5;
  marker.position.y=-.05;
  
  floor = new THREE.Mesh(
			new THREE.PlaneGeometry( 3, 4, 1, 1 ).rotateX( -Math.PI/2 ),
			new THREE.MeshBasicMaterial( { color: 0xbcbcbc, transparent: true, opacity: 0.25 } )
		);
		scene.add( floor );

  const material = new THREE.LineBasicMaterial({ color: 0x000000 });
  var l=-3.05,r=3.05,t=4.05,b=-0.05,z=-5;
  const points = []; //black square
  points.push( new THREE.Vector3( l, b, z ) );
  points.push( new THREE.Vector3( l, t, z ) );
  points.push( new THREE.Vector3( r, t, z ) );
  points.push( new THREE.Vector3( r, b, z ) );
  points.push( new THREE.Vector3( l, b, z ) );
  const geometry = new THREE.BufferGeometry().setFromPoints( points );
  const line = new THREE.Line( geometry, material );
  scene.add( line );

//SQ
const geo = new THREE.BufferGeometry();
  const vertices = [
    -1, 0, z,
    1, 0, z,
    1, 1, z,
    -1, 1, z
  ];
  const indices = [
    0, 1, 2, // first triangle
    2, 3, 0 // second triangle
  ];
  geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geo.setIndex(indices);
  const mat = new THREE.MeshBasicMaterial();
  const sq = new THREE.Mesh(geo, mat);
  scene.add(sq);


  // l-r = 6*100=600
  // t-b = 4*100=400
  // total scaled is 600x400
  //write translation to convert 600x400 to (-3 to 3) and (0 to 4)
  // 4 to 400 is y*100
  // 400 to 4 is y/100
  // 3 to 600 is (x*100)+300
  // 600 to 3 is (x-300)/100

  
  var x1=1,x2=1,y1=2,y2=0;
  
  //console.log(new THREE.Vector3( x1, y1, z ));
  //console.log(new THREE.Vector3( x2, y2, z ));
  
  for (let i=1;i<lines;i++){
   var lnclr = new THREE.LineBasicMaterial({ color: 0x00ff00 });
   var qixp = []; //qix points
   qixp.push( new THREE.Vector3( x1, y1, z ) );
   qixp.push( new THREE.Vector3( x2, y2, z ) );
   var qixg = new THREE.BufferGeometry().setFromPoints( qixp ); //qix geometry
   qix[i] = new THREE.Line( qixg, lnclr ); //3d lines
   scene.add( qix[i] );
  }

	 raycaster = new THREE.Raycaster();

	 renderer = new THREE.WebGLRenderer( { antialias: true } );
	 renderer.setPixelRatio( window.devicePixelRatio );
	 renderer.setSize( window.innerWidth, window.innerHeight );
	 renderer.setAnimationLoop( animate );

	 renderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );
 	renderer.xr.enabled = true;
  
  //renderer.toneMapping = THREE.ACESFilmicToneMapping;
		//renderer.toneMappingExposure = 1;
  renderer.autoClear = false;
  
  //renderer.xr.setReferenceSpaceType( 'local' );
 	document.body.appendChild( renderer.domElement );
 	document.body.appendChild( VRButton.createButton( renderer ) );
  document.body.appendChild( ARButton.createButton( renderer ) );
  window.addEventListener( 'resize', onWindowResize );
  
  			// controllers
				controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'select', onSelect );
				controller1.addEventListener( 'selectstart', onControllerEvent );
				controller1.addEventListener( 'selectend', onControllerEvent );
				controller1.addEventListener( 'move', onControllerEvent );
				controller1.userData.active = false;
				scene.add( controller1 );
				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'select', onSelect );
				controller2.addEventListener( 'selectstart', onControllerEvent );
				controller2.addEventListener( 'selectend', onControllerEvent );
				controller2.addEventListener( 'move', onControllerEvent );
				controller2.userData.active = true;
				scene.add( controller2 );
 			const controllerModelFactory = new XRControllerModelFactory();
				controllerGrip1 = renderer.xr.getControllerGrip( 0 );
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				scene.add( controllerGrip1 );
				controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );
    
   let gm = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				linex = new THREE.Line( gm );
				linex.name = 'linex';
				linex.scale.z = 5;

				raycaster = new THREE.Raycaster();
    
    controls = new TransformControls( camera, renderer.domElement );
				//controls.attach( group.children[ 0 ] );
				scene.add( controls.getHelper() );
 }
			function onSelect( event ) {

				const controller = event.target;

				controller1.userData.active = false;
				controller2.userData.active = false;

				if ( controller === controller1 ) {

					controller1.userData.active = true;
					//controller1.add( linex );

				}

				if ( controller === controller2 ) {

					controller2.userData.active = true;
					//controller2.add( linex );

				}

				raycaster.setFromXRController( controller );

				//const intersects = raycaster.intersectObjects( group.children );

				//if ( intersects.length > 0 ) {

					//controls.attach( intersects[ 0 ].object );

			//	}

			}

			function onControllerEvent( event ) {

				const controller = event.target;

				if ( controller.userData.active === false ) return;

				controls.getRaycaster().setFromXRController( controller );
     //console.log(controls);
    //console.log(event.type);

				switch ( event.type ) {

					case 'selectstart':
						//controls.pointerDown( null );
						break;

					case 'selectend':
						//controls.pointerUp( null );
						break;

					case 'move':
						//controls.pointerHover( null );
						//controls.pointerMove( null );
						break;

				}

			}
 function animate() {
  const session = renderer.xr.getSession();
  if (session) {
   let a,b,c,d,hand,data=[];
   for (const source of session.inputSources) {
    if (source && source.handedness) {
     if (typeof source.handedness!=undefined){
      hand= source.handedness=='left'?1:2;
     } else { hand=0; }
    }
     
    if (!source.gamepad) continue;
      data[hand] = {
      hand: hand,
      buttons: source.gamepad.buttons.map((b) => b.value),
      axes: source.gamepad.axes.slice(0)
     }
    }
     //console.log(hand,data.buttons[4],data.buttons[5],data.axes[2]);
     //console.log(data);
      
      if (data[1]){
       //up-dn 
       a=Math.abs(data[1].axes[3]);
       b=Math.abs(data[2].axes[3]);
       c=a>b?data[1].axes[3]:data[2].axes[3];
       //lf-rt
       a=Math.abs(data[1].axes[2]);
       b=Math.abs(data[2].axes[2]);
       d=a>b?data[1].axes[2]:data[2].axes[2];
       //console.log(c,d);
      }
      
      if (Math.abs(c)>0 || Math.abs(d)>0) {
       if (Math.abs(c)>Math.abs(d)) { //up-dn
        marker.position.y-= c/50;
       } else { //lf-rt
        marker.position.x+= d/50;
       }
       
      if (marker.position.x>3.05){ marker.position.x=3.05; }
      if (marker.position.y>4.05){ marker.position.y=4.05; }
      if (marker.position.x<-3.05){ marker.position.x=-3.05; }
      if (marker.position.y<-.05){ marker.position.y=-.05; }

      }
     }
     /*
     if (data[1].axes[3] || data[2].axes[3]){
      a=data[1].axes[3]<0?data[1].axes[3]*-1:data[1].axes[3];
      b=data[2].axes[3]<0?data[2].axes[3]*-1:data[2].axes[3];
      c=a>b?data[1].axes[3]:data[2].axes[3];
      console.log(a,b,c);
      marker.position.y-= c/50;
     }
     if (data.axes[2]){
      marker.position.x+=data.axes[2]/50;
     }
     if (data.buttons[4]){
      //marker.position.x+=.01;
    }    if (data.buttons[5]){
      //marker.position.x-=.01;
    }
   
   }
  
  */
  
  renderer.render( scene, camera );
 }
 
 function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
 }

</script>
<script>

function trz(n,d=1){
 //write translation to convert 600x400 to (-3 to 3) and (0 to 4)
 var out;
 if (d==1) {
  out=(n-(ww/2))/(ww/6); // 600 to 3 is (x-300)/100
 }
 if (d==2) {
  //out=n*my; // 4 to 400 is y*100 
 }
 if (d==3) {
  out= 4-(n/(hh/4)); // 400 to 4 is y/100
 }
 if (d==4) {
  //out=(n*100)+(mx/2); // 3 to 600 is (x*100)+300
 }
 return out;
}



//var fps=30,step=10,lines=100,chc=lines/6,lw=3;
var rb=["201","001","010","110","120","100"]; rbi=0;
var mx,my,iii,nm=0,iii=999;
var cd=[],rgb=[],cvs=[];
var can=document.getElementById("can");
var ctx=can.getContext("2d");
ctx.lineWidth=lw;
for (let i=0;i<lines;i++){
  nm+=Math.round(255/lines);
  cvs.push(nm);
  rgb.push([ 0,0,0 ]);
}
window.onresize = function(event) { init(); };
init();
setInterval(frame,1000/fps);

function init(){
 can.width=window.innerWidth; can.height=window.innerHeight;
 mx=can.width; my=can.height;
}

function rand(lo,hi=1,st=0){
 if (lo=="t"){out=Math.round(Math.random()) ? -1:1;}else{out=(Math.round(Math.random()*(hi-lo)))+lo;}
 return st ? String(out):out;
}

function x(x){
  out=[0,0,0];
  for (let z=0;z<3;z++){
   if (x[z]=="0") { out[z]=0 }
   else if (x[z]=="1") { out[z]=cvs[lines-1] }
   else if (x[z]=="2") { out[z]=cvs[lines-1]/2 }
  }
  return out;
}

function frame(){
 iii++;
 if (iii>chc){
  iii=0;
  rbi++;
  rbi= rbi>rb.length-1 ? 0 : rbi;
  
  tmp=[ rb[rbi][0],rb[rbi][1],rb[rbi][2]] ;
  tmp=x(tmp);
 } else {
  tmp=[rgb[lines-1][0],rgb[lines-1][1],rgb[lines-1][2]];
 }
 rgb.shift(); 
 rgb.push(tmp);
 
 ctx.fillStyle="#000000";
 ctx.fillRect(0,0,mx,my);
 for (let i=0;i<lines;i++){
 
 if (i<lines-1){
  for (let it=0;it<3;it++){
   if (rgb[i][it]==0) { rgb[i][it]=0 }
   else if (rgb[i][it]<cvs[i+1]) { rgb[i][it]=cvs[i]/2 }
   else { rgb[i][it]=cvs[i] }
  }
 }
 
  if (cd[i]==undefined && i>0){
   cd.push([cd[i-1][0]+step,cd[i-1][1]+step,cd[i-1][2]+step,cd[i-1][3]+step]);
  }
  if (cd[i]==undefined && i==0){
   cd.push([rand(9,mx-9),rand(9,my-9),rand(9,mx-9),rand(9,my-9)]);
   vt=[rand("t"),rand("t"),rand("t"),rand("t")];
  }
  if (i==0){
   if (cd[i][0]>5 && cd[i][0]<mx-5){
    vt[0]=rand(0,200)!=1 ? vt[0] : vt[0]*-1;
   }
   if (cd[i][1]>5 && cd[i][1]<my-5){
    vt[1]=rand(0,200)!=1 ? vt[1] : vt[1]*-1;
   }
   if (cd[i][2]>5 && cd[i][2]<mx-5){
    vt[2]=rand(0,200)!=1 ? vt[2] : vt[2]*-1;
   }
   if (cd[i][3]>5 && cd[i][3]<my-5){
    vt[3]=rand(0,200)!=1 ? vt[3] : vt[3]*-1;
   }
   if(cd[i][0]>mx){ vt[0]=-1; }
   if(cd[i][0]<0) { vt[0]=1; }
   if(cd[i][1]>my){ vt[1]=-1; }
   if(cd[i][1]<0) { vt[1]=1; }
   if(cd[i][2]>mx){ vt[2]=-1; }
   if(cd[i][2]<0) { vt[2]=1; }
   if(cd[i][3]>my){ vt[3]=-1; }
   if(cd[i][3]<0) { vt[3]=1; }
   cd.unshift([cd[i][0]+vt[0]*step,cd[i][1]+vt[1]*step,cd[i][2]+vt[2]*step,cd[i][3]+vt[3]*step]);
   cd.pop();
  }
  if (cd[lines-i]!=undefined){
   r=rgb[i][0]; g=rgb[i][1]; b=rgb[i][2];
   ctx.strokeStyle="rgba("+r+","+g+","+b+",200)";
   ctx.beginPath(); ctx.moveTo(cd[lines-i][0],cd[lines-i][1]);
   ctx.lineTo(cd[lines-i][2],cd[lines-i][3]); ctx.stroke();
   qix[i].material.color.r=r/255;
   qix[i].material.color.g=g/255;
   qix[i].material.color.b=b/255;
   
   qix[i].geometry.attributes.position.array[0]=trz(cd[lines-i][0],1);
   qix[i].geometry.attributes.position.array[1]=trz(cd[lines-i][1],3);
   //qix[i].geometry.attributes.position.array[2]=trz((cd[lines-i][1])/3,1);
   qix[i].geometry.attributes.position.array[3]=trz(cd[lines-i][2],1);
   qix[i].geometry.attributes.position.array[4]=trz(cd[lines-i][3],3);
   //qix[i].geometry.attributes.position.array[5]=trz((cd[lines-i][3])/3,1);
   qix[i].geometry.attributes.position.needsUpdate = true;
   //console.log('cd',cd[i]);
   //console.log('q1',qix[1].geometry.attributes.position.array[1]);
   //console.log('q2',qix[i].geometry.attributes.position.array[1]);
  }
 }
}

</script>
</body>
</html>