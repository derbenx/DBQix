<!DOCTYPE html>
<html>
<head>
    <title>Canvas Test</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="600" height="600"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        // --- Parameters ---
        const squareSize = 400;
        const canvasSize = 600;
        const squareX = (canvasSize - squareSize) / 2;
        const squareY = (canvasSize - squareSize) / 2;
        const centerPoint = [canvasSize / 2, canvasSize / 2];

        // --- Paths ---
        let borderPath = [
            [squareX, squareY],
            [squareX + squareSize, squareY],
            [squareX + squareSize, squareY + squareSize],
            [squareX, squareY + squareSize]
        ];
        let currentDrawnPath = [];

        // --- State ---
        let dot = {
            x: borderPath[0][0],
            y: borderPath[0][1],
            size: 5,
            speed: 2,
            onBorder: true,
            currentEdgeIndex: 0,
            positionOnEdge: 0
        };
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Control: false };
        let isDrawing = false;
        let drawingDirection = null;
        let lastMove = { dx: 0, dy: 0 };

        // --- Drawing Functions ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'blue';
            if (borderPath.length > 0) {
                ctx.beginPath();
                ctx.moveTo(borderPath[0][0], borderPath[0][1]);
                for(let i = 1; i < borderPath.length; i++) ctx.lineTo(borderPath[i][0], borderPath[i][1]);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            if (isDrawing) {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 2;
                if (currentDrawnPath.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(currentDrawnPath[0][0], currentDrawnPath[0][1]);
                    for (let i = 1; i < currentDrawnPath.length; i++) ctx.lineTo(currentDrawnPath[i][0], currentDrawnPath[i][1]);
                    ctx.lineTo(dot.x, dot.y);
                    ctx.stroke();
                }
            }
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.size, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();
        }

        // --- Collision & Path Functions ---
        function isPointOnSegment(p, a, b) {
            const cp = (p[1] - a[1]) * (b[0] - a[0]) - (p[0] - a[0]) * (b[1] - a[1]);
            if (Math.abs(cp) > 1) return false;
            const dp = (p[0] - a[0]) * (b[0] - a[0]) + (p[1] - a[1]) * (b[1] - a[1]);
            if (dp < 0) return false;
            const sl_ba = (b[0] - a[0])**2 + (b[1] - a[1])**2;
            if (dp > sl_ba) return false;
            return true;
        }

        function isOnBorder(point, path) {
            for (let i = 0; i < path.length; i++) {
                const p1 = path[i];
                const p2 = path[(i + 1) % path.length];
                if (isPointOnSegment(point, p1, p2)) return true;
            }
            return false;
        }

        function findEdgeForPoint(point, polygonPath) {
            for (let i = 0; i < polygonPath.length; i++) {
                if (isPointOnSegment(point, polygonPath[i], polygonPath[(i + 1) % polygonPath.length])) return i;
            }
            return -1;
        }
        
        function isPointInPolygon(point, polygon) {
            let x = point[0], y = point[1];
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i][0], yi = polygon[i][1];
                let xj = polygon[j][0], yj = polygon[j][1];
                let intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function segmentsIntersect(p1, p2, p3, p4) {
            const isMoveVertical = p1.x === p2.x;
            const isPathVertical = p3.x === p4.x;
            if (isMoveVertical && !isPathVertical) {
                const isCrossingX = p1.x >= Math.min(p3.x, p4.x) && p1.x <= Math.max(p3.x, p4.x);
                const isCrossingY = p3.y >= Math.min(p1.y, p2.y) && p3.y <= Math.max(p1.y, p2.y);
                return isCrossingX && isCrossingY;
            } else if (!isMoveVertical && isPathVertical) {
                const isCrossingX = p3.x >= Math.min(p1.x, p2.x) && p3.x <= Math.max(p1.x, p2.x);
                const isCrossingY = p1.y >= Math.min(p3.y, p4.y) && p1.y <= Math.max(p3.y, p4.y);
                return isCrossingX && isCrossingY;
            }
            return false;
        }

        // --- Game Logic ---
        function handleAreaCapture(path) {
            let startEdgeIdx = findEdgeForPoint(path[0], borderPath);
            let endEdgeIdx = findEdgeForPoint(path[path.length - 1], borderPath);

            if (startEdgeIdx === -1 || endEdgeIdx === -1 || startEdgeIdx === endEdgeIdx) {
                currentDrawnPath = []; return;
            }

            const polygon1 = [], polygon2 = [];
            let i = (startEdgeIdx + 1) % borderPath.length;
            while (i !== (endEdgeIdx + 1) % borderPath.length) {
                polygon1.push(borderPath[i]); i = (i + 1) % borderPath.length;
            }
            polygon1.push(...[...path].reverse());
            i = (endEdgeIdx + 1) % borderPath.length;
            while (i !== (startEdgeIdx + 1) % borderPath.length) {
                polygon2.push(borderPath[i]); i = (i + 1) % borderPath.length;
            }
            polygon2.push(...path);
            borderPath = isPointInPolygon(centerPoint, polygon1) ? polygon1 : polygon2;
            currentDrawnPath = [];
            dot.x = borderPath[0][0]; dot.y = borderPath[0][1];
            dot.onBorder = true; dot.currentEdgeIndex = 0; dot.positionOnEdge = 0;
        }

        function update() {
            if (dot.onBorder) updateBorderMode();
            else if (isDrawing) updateDrawingMode();
        }

        function updateBorderMode() {
            const edgeIndex = dot.currentEdgeIndex;
            const startNode = borderPath[edgeIndex];
            const endNode = borderPath[(edgeIndex + 1) % borderPath.length];
            const edgeVector = [endNode[0] - startNode[0], endNode[1] - startNode[1]];
            const edgeLength = Math.sqrt(edgeVector[0]**2 + edgeVector[1]**2);
            
            let forward = false, backward = false;
            if (Math.abs(edgeVector[0]) > Math.abs(edgeVector[1])) {
                if (edgeVector[0] > 0) { forward = keys.ArrowRight; backward = keys.ArrowLeft; }
                else { forward = keys.ArrowLeft; backward = keys.ArrowRight; }
            } else {
                if (edgeVector[1] > 0) { forward = keys.ArrowDown; backward = keys.ArrowUp; }
                else { forward = keys.ArrowUp; backward = keys.ArrowDown; }
            }
            
            if (forward) dot.positionOnEdge += dot.speed;
            if (backward) dot.positionOnEdge -= dot.speed;

            if (dot.positionOnEdge > edgeLength) {
                dot.currentEdgeIndex = (dot.currentEdgeIndex + 1) % borderPath.length;
                dot.positionOnEdge -= edgeLength;
            } else if (dot.positionOnEdge < 0) {
                dot.currentEdgeIndex = (dot.currentEdgeIndex - 1 + borderPath.length) % borderPath.length;
                const pES = borderPath[dot.currentEdgeIndex], pEE = borderPath[(dot.currentEdgeIndex + 1) % borderPath.length];
                dot.positionOnEdge += Math.sqrt((pEE[0] - pES[0])**2 + (pEE[1] - pES[1])**2);
            }

            const nES = borderPath[dot.currentEdgeIndex], nEE = borderPath[(dot.currentEdgeIndex + 1) % borderPath.length];
            const nEV = [nEE[0] - nES[0], nEE[1] - nES[1]], nEL = Math.sqrt(nEV[0]**2 + nEV[1]**2);
            const uV = [nEV[0] / nEL, nEV[1] / nEL];
            dot.x = nES[0] + uV[0] * dot.positionOnEdge;
            dot.y = nES[1] + uV[1] * dot.positionOnEdge;

            if (keys.Control) {
                const normalVec = [-uV[1], uV[0]];
                let dx = 0, dy = 0;
                if (Math.abs(normalVec[0]) > Math.abs(normalVec[1])) {
                    if (normalVec[0] > 0 && keys.ArrowRight) dx = dot.speed;
                    else if (normalVec[0] < 0 && keys.ArrowLeft) dx = -dot.speed;
                } else {
                    if (normalVec[1] > 0 && keys.ArrowDown) dy = dot.speed;
                    else if (normalVec[1] < 0 && keys.ArrowUp) dy = -dot.speed;
                }
                if ((dx !== 0 || dy !== 0) && isPointInPolygon([dot.x + dx, dot.y + dy], borderPath)) {
                    isDrawing = true; dot.onBorder = false; drawingDirection = (dx !== 0) ? 'horizontal' : 'vertical';
                    lastMove = { dx, dy }; currentDrawnPath.push([dot.x, dot.y]); dot.x += dx; dot.y += dy;
                }
            }
        }

        function updateDrawingMode() {
            let dx = 0, dy = 0;
            if (keys.ArrowUp) { dy = -dot.speed; } else if (keys.ArrowDown) { dy = dot.speed; }
            else if (keys.ArrowLeft) { dx = -dot.speed; } else if (keys.ArrowRight) { dx = dot.speed; }
            if (dx === 0 && dy === 0) return;
            if (dx === -lastMove.dx && dy === -lastMove.dy) return;

            const moveFrom = { x: dot.x, y: dot.y }, moveTo = { x: dot.x + dx, y: dot.y + dy };
            if (currentDrawnPath.length >= 3) {
                for (let i = 0; i < currentDrawnPath.length - 2; i++) {
                    if (segmentsIntersect(moveFrom, moveTo, {x:currentDrawnPath[i][0], y:currentDrawnPath[i][1]}, {x:currentDrawnPath[i+1][0], y:currentDrawnPath[i+1][1]})) return;
                }
            }
            
            const newMovementDirection = (dx !== 0) ? 'horizontal' : 'vertical';
            if (drawingDirection !== null && newMovementDirection !== drawingDirection) {
                currentDrawnPath.push([dot.x, dot.y]);
            }
            drawingDirection = newMovementDirection;
            const newPoint = [dot.x + dx, dot.y + dy];
            
            if (isOnBorder(newPoint, borderPath)) {
                dot.x = newPoint[0]; dot.y = newPoint[1]; isDrawing = false; dot.onBorder = true;
                lastMove = { dx: 0, dy: 0 }; currentDrawnPath.push([dot.x, dot.y]);
                handleAreaCapture(currentDrawnPath);
                dot.currentEdgeIndex = findEdgeForPoint([dot.x, dot.y], borderPath);
                dot.positionOnEdge = 0;
            } else if (isPointInPolygon(newPoint, borderPath)) {
                dot.x = newPoint[0]; dot.y = newPoint[1]; lastMove = { dx, dy };
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (event) => { if (event.key in keys) { keys[event.key] = true; event.preventDefault();} });
        document.addEventListener('keyup', (event) => { if (event.key in keys) { keys[event.key] = false; event.preventDefault();} });

        gameLoop();
    </script>
</body>
</html>
