<!DOCTYPE html>
<html>
<head>
    <title>Canvas Test</title>
    <style>
        body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f0f0f0; }
        canvas { border: 1px solid #ccc; }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="600" height="600"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        const canvasSize = 600;
        const centerPoint = [canvasSize / 2, canvasSize / 2];

        let borderPath = [ [100, 100], [500, 100], [500, 500], [100, 500] ];
        let currentDrawnPath = [];

        let dot = {
            x: borderPath[0][0], y: borderPath[0][1], size: 5, speed: 4,
            onBorder: true, currentEdgeIndex: 0, positionOnEdge: 0
        };
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Control: false };
        let isDrawing = false;
        let drawingDirection = null;
        let lastMove = { dx: 0, dy: 0 };

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'blue';
            if (borderPath.length > 0) {
                ctx.beginPath();
                ctx.moveTo(borderPath[0][0], borderPath[0][1]);
                for(let i = 1; i < borderPath.length; i++) ctx.lineTo(borderPath[i][0], borderPath[i][1]);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            if (isDrawing && currentDrawnPath.length > 0) {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(currentDrawnPath[0][0], currentDrawnPath[0][1]);
                for (let i = 1; i < currentDrawnPath.length; i++) ctx.lineTo(currentDrawnPath[i][0], currentDrawnPath[i][1]);
                ctx.lineTo(dot.x, dot.y);
                ctx.stroke();
            }
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.size, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();
        }

        function isPointOnSegment(p, a, b) {
            const cp = (p[1] - a[1]) * (b[0] - a[0]) - (p[0] - a[0]) * (b[1] - a[1]);
            if (Math.abs(cp) > 1) return false;
            const dp = (p[0] - a[0]) * (b[0] - a[0]) + (p[1] - a[1]) * (b[1] - a[1]);
            if (dp < 0) return false;
            const sl_ba = (b[0] - a[0])**2 + (b[1] - a[1])**2;
            if (dp > sl_ba) return false;
            return true;
        }

        function isOnBorder(point, path) {
            for (let i = 0; i < path.length; i++) {
                if (isPointOnSegment(point, path[i], path[(i + 1) % path.length])) return true;
            }
            return false;
        }

        function findEdgeForPoint(point, polygonPath) {
            for (let i = 0; i < polygonPath.length; i++) {
                if (isPointOnSegment(point, polygonPath[i], polygonPath[(i + 1) % polygonPath.length])) return i;
            }
            return -1;
        }

        function isPointInPolygon(point, polygon) {
            let x = point[0], y = point[1];
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i][0], yi = polygon[i][1];
                let xj = polygon[j][0], yj = polygon[j][1];
                let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function segmentsIntersect(p1, p2, p3, p4) {
            const isMoveVertical = p1.x === p2.x;
            const isPathVertical = p3.x === p4.x;
            if (isMoveVertical && !isPathVertical) {
                const isCrossingX = p1.x >= Math.min(p3.x, p4.x) && p1.x <= Math.max(p3.x, p4.x);
                const isCrossingY = p3.y >= Math.min(p1.y, p2.y) && p3.y <= Math.max(p1.y, p2.y);
                return isCrossingX && isCrossingY;
            } else if (!isMoveVertical && isPathVertical) {
                const isCrossingX = p3.x >= Math.min(p1.x, p2.x) && p3.x <= Math.max(p1.x, p2.x);
                const isCrossingY = p1.y >= Math.min(p3.y, p4.y) && p1.y <= Math.max(p3.y, p4.y);
                return isCrossingX && isCrossingY;
            }
            return false;
        }

        function normalizeWindingOrder(polygon) {
            let area = 0;
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % polygon.length];
                area += (p1[0] * p2[1]) - (p2[0] * p1[1]);
            }
            if (area > 0) { polygon.reverse(); }
            return polygon;
        }

        function handleAreaCapture(path) {
            if (path.length < 2) return;
            const startPoint = path[0];
            const endPoint = path[path.length - 1];
            let startEdgeIdx = findEdgeForPoint(startPoint, borderPath);
            let endEdgeIdx = findEdgeForPoint(endPoint, borderPath);

            if (startEdgeIdx === -1 || endEdgeIdx === -1) { currentDrawnPath = []; return; }

            let polygon1, polygon2;

            if (startEdgeIdx === endEdgeIdx) {
                const edgeV1 = borderPath[startEdgeIdx];
                const dist1 = Math.hypot(startPoint[0] - edgeV1[0], startPoint[1] - edgeV1[1]);
                const dist2 = Math.hypot(endPoint[0] - edgeV1[0], endPoint[1] - edgeV1[1]);
                if (dist1 > dist2) { path = path.reverse(); }

                polygon1 = [...path];
                polygon2 = [...borderPath];
                polygon2.splice(startEdgeIdx + 1, 0, ...path);
            } else {
                const p1 = [], p2 = [];
                let i = (startEdgeIdx + 1) % borderPath.length;
                while (i !== (endEdgeIdx + 1) % borderPath.length) {
                    p1.push(borderPath[i]); i = (i + 1) % borderPath.length;
                }
                p1.push(...[...path].reverse());

                i = (endEdgeIdx + 1) % borderPath.length;
                while (i !== (startEdgeIdx + 1) % borderPath.length) {
                    p2.push(borderPath[i]); i = (i + 1) % borderPath.length;
                }
                p2.push(...path);
                polygon1 = p1;
                polygon2 = p2;
            }

            normalizeWindingOrder(polygon1);
            normalizeWindingOrder(polygon2);

            borderPath = isPointInPolygon(centerPoint, polygon1) ? polygon1 : polygon2;
            currentDrawnPath = [];

            dot.x = endPoint[0];
            dot.y = endPoint[1];
            dot.onBorder = true;

            const newEdgeIndex = findEdgeForPoint(endPoint, borderPath);
            if (newEdgeIndex !== -1) {
                dot.currentEdgeIndex = newEdgeIndex;
                const startOfNewEdge = borderPath[newEdgeIndex];
                dot.positionOnEdge = Math.hypot(dot.x - startOfNewEdge[0], dot.y - startOfNewEdge[1]);
            } else {
                dot.x = borderPath[0][0];
                dot.y = borderPath[0][1];
                dot.currentEdgeIndex = 0;
                dot.positionOnEdge = 0;
            }
        }

        function update() {
            if (dot.onBorder) updateBorderMode();
            else if (isDrawing) updateDrawingMode();
        }

        function updateBorderMode() {
            const edgeIndex = dot.currentEdgeIndex;
            if (edgeIndex === -1 || edgeIndex >= borderPath.length) { dot.currentEdgeIndex = 0; return; }
            const startNode = borderPath[edgeIndex];
            const endNode = borderPath[(edgeIndex + 1) % borderPath.length];
            const edgeVector = [endNode[0] - startNode[0], endNode[1] - startNode[1]];
            const edgeLength = Math.sqrt(edgeVector[0]**2 + edgeVector[1]**2);
            let move = 0;
            if (Math.abs(edgeVector[0]) > Math.abs(edgeVector[1])) {
                if (edgeVector[0] > 0) { if(keys.ArrowRight) move = dot.speed; if(keys.ArrowLeft) move = -dot.speed; }
                else { if(keys.ArrowLeft) move = dot.speed; if(keys.ArrowRight) move = -dot.speed; }
            } else {
                if (edgeVector[1] > 0) { if(keys.ArrowDown) move = dot.speed; if(keys.ArrowUp) move = -dot.speed; }
                else { if(keys.ArrowUp) move = dot.speed; if(keys.ArrowDown) move = -dot.speed; }
            }
            dot.positionOnEdge += move;
            if (edgeLength > 0 && dot.positionOnEdge > edgeLength) {
                dot.currentEdgeIndex = (dot.currentEdgeIndex + 1) % borderPath.length;
                dot.positionOnEdge -= edgeLength;
            } else if (dot.positionOnEdge < 0) {
                dot.currentEdgeIndex = (dot.currentEdgeIndex - 1 + borderPath.length) % borderPath.length;
                const pES = borderPath[dot.currentEdgeIndex], pEE = borderPath[(dot.currentEdgeIndex + 1) % borderPath.length];
                dot.positionOnEdge += Math.sqrt((pEE[0] - pES[0])**2 + (pEE[1] - pES[1])**2);
            }
            const newEdgeStart = borderPath[dot.currentEdgeIndex], newEdgeEnd = borderPath[(dot.currentEdgeIndex + 1) % borderPath.length];
            const newEdgeVec = [newEdgeEnd[0] - newEdgeStart[0], newEdgeEnd[1] - newEdgeStart[1]];
            const newEdgeLen = Math.sqrt(newEdgeVec[0]**2 + newEdgeVec[1]**2);
            if (newEdgeLen > 0) {
                const unitVec = [newEdgeVec[0] / newEdgeLen, newEdgeVec[1] / newEdgeLen];
                dot.x = newEdgeStart[0] + unitVec[0] * dot.positionOnEdge;
                dot.y = newEdgeStart[1] + unitVec[1] * dot.positionOnEdge;
            }
            if (keys.Control) {
                let dx = 0, dy = 0;
                if (keys.ArrowUp) { dy = -dot.speed; }
                else if (keys.ArrowDown) { dy = dot.speed; }
                else if (keys.ArrowLeft) { dx = -dot.speed; }
                else if (keys.ArrowRight) { dx = dot.speed; }
                if (dx !== 0 || dy !== 0) {
                    const testPoint = [dot.x + dx, dot.y + dy];
                    if (isPointInPolygon(testPoint, borderPath) && !isOnBorder(testPoint, borderPath)) {
                        isDrawing = true; dot.onBorder = false; drawingDirection = (dx !== 0) ? 'horizontal' : 'vertical';
                        lastMove = { dx, dy }; currentDrawnPath.push([dot.x, dot.y]);
                        dot.x += dx; dot.y += dy;
                    }
                }
            }
        }

        function updateDrawingMode() {
            let dx = 0, dy = 0;
            if (keys.ArrowUp) { dy = -dot.speed; } else if (keys.ArrowDown) { dy = dot.speed; }
            else if (keys.ArrowLeft) { dx = -dot.speed; } else if (keys.ArrowRight) { dx = dot.speed; }
            if (dx === 0 && dy === 0) return;
            if (dx === -lastMove.dx && dy === -lastMove.dy) return;
            const moveFrom = { x: dot.x, y: dot.y }, moveTo = { x: dot.x + dx, y: dot.y + dy };
            if (currentDrawnPath.length >= 3) {
                for (let i = 0; i < currentDrawnPath.length - 2; i++) {
                    if (segmentsIntersect(moveFrom, moveTo, {x:currentDrawnPath[i][0], y:currentDrawnPath[i][1]}, {x:currentDrawnPath[i+1][0], y:currentDrawnPath[i+1][1]})) return;
                }
            }
            const newMovementDirection = (dx !== 0) ? 'horizontal' : 'vertical';
            if (drawingDirection !== null && newMovementDirection !== drawingDirection) {
                currentDrawnPath.push([dot.x, dot.y]);
            }
            drawingDirection = newMovementDirection;
            const newPoint = [dot.x + dx, dot.y + dy];
            if (isOnBorder(newPoint, borderPath)) {
                dot.x = newPoint[0]; dot.y = newPoint[1]; isDrawing = false; dot.onBorder = true;
                lastMove = { dx: 0, dy: 0 }; currentDrawnPath.push([dot.x, dot.y]);
                handleAreaCapture(currentDrawnPath);
            } else if (isPointInPolygon(newPoint, borderPath)) {
                dot.x = newPoint[0]; dot.y = newPoint[1]; lastMove = { dx, dy };
            }
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
        document.addEventListener('keydown', (event) => { if (event.key in keys) { keys[event.key] = true; event.preventDefault();} });
        document.addEventListener('keyup', (event) => { if (event.key in keys) { keys[event.key] = false; event.preventDefault();} });
        gameLoop();
    </script>
</body>
</html>
