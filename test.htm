<!DOCTYPE html>
<html>
<head>
    <title>Canvas Test</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="600" height="600"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        // --- Parameters ---
        const squareSize = 400;
        const canvasSize = 600;
        const squareX = (canvasSize - squareSize) / 2;
        const squareY = (canvasSize - squareSize) / 2;

        // --- Paths ---
        const borderPath = [
            [squareX, squareY],
            [squareX + squareSize, squareY],
            [squareX + squareSize, squareY + squareSize],
            [squareX, squareY + squareSize],
            [squareX, squareY]
        ];
        let drawnPaths = [];
        let currentDrawnPath = [];

        // --- State ---
        let dot = { x: borderPath[0][0], y: borderPath[0][1], size: 5, speed: 2 };
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Control: false };
        let isDrawing = false;
        let drawingDirection = null; // 'horizontal' or 'vertical'
        let lastMove = { dx: 0, dy: 0 };

        // --- Drawing Functions ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'blue';
            ctx.fillRect(squareX, squareY, squareSize, squareSize);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeRect(squareX, squareY, squareSize, squareSize);
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 2;
            drawnPaths.forEach(path => drawLine(path));
            drawLine(currentDrawnPath);
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.size, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();
        }

        function drawLine(path) {
            if (path.length < 1) return;
            ctx.beginPath();
            ctx.moveTo(path[0][0], path[0][1]);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i][0], path[i][1]);
            }
            if (isDrawing && path === currentDrawnPath) {
                ctx.lineTo(dot.x, dot.y);
            }
            ctx.stroke();
        }

        // --- Collision & Path Functions ---
        function isOnBorder(px, py) {
            const tolerance = 1;
            for (let i = 0; i < borderPath.length - 1; i++) {
                const p1 = borderPath[i], p2 = borderPath[i + 1];
                const x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1];
                if (Math.abs(y1 - y2) < tolerance) {
                    if (Math.abs(py - y1) < tolerance && px >= Math.min(x1, x2) - tolerance && px <= Math.max(x1, x2) + tolerance) return true;
                } else if (Math.abs(x1 - x2) < tolerance) {
                    if (Math.abs(px - x1) < tolerance && py >= Math.min(y1, y2) - tolerance && py <= Math.max(y1, y2) + tolerance) return true;
                }
            }
            return false;
        }

        function segmentsIntersect(p1, p2, p3, p4) {
            const isMoveVertical = p1.x === p2.x;
            const isPathVertical = p3.x === p4.x;
            if (isMoveVertical && !isPathVertical) { // Vertical move, Horizontal path
                const isCrossingX = p1.x >= Math.min(p3.x, p4.x) && p1.x <= Math.max(p3.x, p4.x);
                const isCrossingY = p3.y >= Math.min(p1.y, p2.y) && p3.y <= Math.max(p1.y, p2.y);
                return isCrossingX && isCrossingY;
            } else if (!isMoveVertical && isPathVertical) { // Horizontal move, Vertical path
                const isCrossingX = p3.x >= Math.min(p1.x, p2.x) && p3.x <= Math.max(p1.x, p2.x);
                const isCrossingY = p1.y >= Math.min(p3.y, p4.y) && p1.y <= Math.max(p3.y, p4.y);
                return isCrossingX && isCrossingY;
            }
            return false;
        }

        // --- Game Logic ---
        function update() {
            if (isDrawing) updateDrawingMode();
            else updateBorderMode();
        }

        function updateBorderMode() {
            if (keys.Control) {
                let dx = 0, dy = 0, direction = null;
                if (keys.ArrowDown && dot.y === squareY) { dy = dot.speed; direction = 'vertical'; }
                else if (keys.ArrowUp && dot.y === squareY + squareSize) { dy = -dot.speed; direction = 'vertical'; }
                else if (keys.ArrowRight && dot.x === squareX) { dx = dot.speed; direction = 'horizontal'; }
                else if (keys.ArrowLeft && dot.x === squareX + squareSize) { dx = -dot.speed; direction = 'horizontal'; }
                if (direction) {
                    isDrawing = true;
                    drawingDirection = direction;
                    lastMove = { dx, dy }; // Set initial move direction
                    currentDrawnPath.push([dot.x, dot.y]);
                    dot.x += dx;
                    dot.y += dy;
                    return;
                }
            }
            let moved = false;
            if (keys.ArrowUp && !moved && isOnBorder(dot.x, dot.y - dot.speed)) { dot.y -= dot.speed; moved = true; }
            if (keys.ArrowDown && !moved && isOnBorder(dot.x, dot.y + dot.speed)) { dot.y += dot.speed; moved = true; }
            if (keys.ArrowLeft && !moved && isOnBorder(dot.x - dot.speed, dot.y)) { dot.x -= dot.speed; moved = true; }
            if (keys.ArrowRight && !moved && isOnBorder(dot.x + dot.speed, dot.y)) { dot.x += dot.speed; }
        }

        function updateDrawingMode() {
            let dx = 0, dy = 0;
            if (keys.ArrowUp) { dy = -dot.speed; }
            else if (keys.ArrowDown) { dy = dot.speed; }
            else if (keys.ArrowLeft) { dx = -dot.speed; }
            else if (keys.ArrowRight) { dx = dot.speed; }
            if (dx === 0 && dy === 0) return;

            if (dx === -lastMove.dx && dy === -lastMove.dy) return;

            const moveFrom = { x: dot.x, y: dot.y };
            const moveTo = { x: dot.x + dx, y: dot.y + dy };
            if (currentDrawnPath.length >= 3) {
                 // Check against all segments except the last one, which we are extending.
                for (let i = 0; i < currentDrawnPath.length - 2; i++) {
                    const p1 = { x: currentDrawnPath[i][0], y: currentDrawnPath[i][1] };
                    const p2 = { x: currentDrawnPath[i+1][0], y: currentDrawnPath[i+1][1] };
                    if (segmentsIntersect(moveFrom, moveTo, p1, p2)) return;
                }
            }

            const newMovementDirection = (dx !== 0) ? 'horizontal' : 'vertical';
            if (drawingDirection !== null && newMovementDirection !== drawingDirection) {
                currentDrawnPath.push([dot.x, dot.y]);
            }
            drawingDirection = newMovementDirection;
            const newX = dot.x + dx, newY = dot.y + dy;
            const buffer = 1;
            if (newX >= squareX + buffer && newX <= squareX + squareSize - buffer &&
                newY >= squareY + buffer && newY <= squareY + squareSize - buffer) {
                dot.x = newX;
                dot.y = newY;
                lastMove = { dx, dy };
            } else if (isOnBorder(newX, newY)) {
                dot.x = newX;
                dot.y = newY;
                isDrawing = false;
                drawingDirection = null;
                lastMove = { dx: 0, dy: 0 };
                currentDrawnPath.push([dot.x, dot.y]);
                drawnPaths.push([...currentDrawnPath]);
                currentDrawnPath = [];
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (event) => { if (event.key in keys) { keys[event.key] = true; event.preventDefault();} });
        document.addEventListener('keyup', (event) => { if (event.key in keys) { keys[event.key] = false; event.preventDefault();} });

        gameLoop();
    </script>
</body>
</html>
